"use strict";
// Copyright 2016-2025, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPulumiType = exports.isStackPolicy = exports.isResourcePolicy = exports.Secret = exports.validateStackResourcesOfType = exports.validateRemediateResourceOfType = exports.validateResourceOfType = exports.remediateResourceOfType = exports.PolicyPack = void 0;
const server_1 = require("./server");
const defaultEnforcementLevel = "advisory";
/**
 * A PolicyPack contains one or more policies to enforce.
 *
 * For example:
 *
 * ```typescript
 * import * as aws from "@pulumi/aws";
 * import { PolicyPack, validateResourceOfType } from "@pulumi/policy";
 *
 * new PolicyPack("aws-typescript", {
 *     policies: [{
 *         name: "s3-no-public-read",
 *         description: "Prohibits setting the publicRead or publicReadWrite permission on AWS S3 buckets.",
 *         enforcementLevel: "mandatory",
 *         validateResource: validateResourceOfType(aws.s3.Bucket, (bucket, args, reportViolation) => {
 *             if (bucket.acl === "public-read" || bucket.acl === "public-read-write") {
 *                 reportViolation("You cannot set public-read or public-read-write on an S3 bucket.");
 *             }
 *         }),
 *     }],
 * });
 * ```
 */
class PolicyPack {
    constructor(name, args, initialConfig) {
        this.name = name;
        this.policies = args.policies;
        // Get package version from the package.json file.
        const cwd = process.cwd();
        const pkg = require(`${cwd}/package.json`);
        const version = pkg.version;
        if (!version || version === "") {
            throw new Error("Version must be defined in the package.json file.");
        }
        const enforcementLevel = args.enforcementLevel || defaultEnforcementLevel;
        server_1.serve(this.name, version, enforcementLevel, args, initialConfig);
    }
}
exports.PolicyPack = PolicyPack;
/**
 * A helper function that returns a strongly-typed resource remediation function, used to check only resources of
 * the specified resource type.
 *
 * For example:
 *
 * ```typescript
 * remediateResource: remediateResourceOfType(aws.s3.Bucket, (bucket, args) => {
 *     bucket.tags = { "foo": "bar" };
 *     return bucket;
 * }),
 * ```
 *
 * @param resourceClass Used to filter this check to only resources of the specified resource class.
 * @param remediate A callback function that optionally remediates a resource if it violates a policy.
 */
function remediateResourceOfType(resourceClass, remediate) {
    const fn = (args) => {
        if (args.isType(resourceClass)) {
            return remediate(args.props, args);
        }
        else {
            notApplicableType(args, resourceClass);
        }
    };
    // If resourceClass has a Pulumi type, attach it to the function so it can be used for more efficient filtering.
    const pulumiType = getPulumiType(resourceClass);
    if (pulumiType) {
        fn.__pulumiType = pulumiType;
    }
    return fn;
}
exports.remediateResourceOfType = remediateResourceOfType;
/**
 * A helper function that returns a strongly-typed resource validation function, used to check only resources of the
 * specified resource class.
 *
 * For example:
 *
 * ```typescript
 * validateResource: validateResourceOfType(aws.s3.Bucket, (bucket, args, reportViolation) => {
 *     if (bucket.acl === "public-read" || bucket.acl === "public-read-write") {
 *         reportViolation("You cannot set public-read or public-read-write on an S3 bucket.");
 *     }
 * }),
 * ```
 *
 * @param resourceClass Used to filter this check to only resources of the specified resource class.
 * @param validate A callback function that validates if the resource definition violates a policy.
 */
function validateResourceOfType(resourceClass, validate) {
    const fn = (args, reportViolation) => {
        if (args.isType(resourceClass)) {
            return validate(args.props, args, reportViolation);
        }
        else {
            notApplicableType(args, resourceClass);
        }
    };
    // If resourceClass has a Pulumi type, attach it to the function so it can be used for more efficient filtering.
    const pulumiType = getPulumiType(resourceClass);
    if (pulumiType) {
        fn.__pulumiType = pulumiType;
    }
    return fn;
}
exports.validateResourceOfType = validateResourceOfType;
/**
 * A helper function for the pattern where a single function wants to be able to remediate *and*
 * validate depending on how it is called. It returns both the validateResource and remediateResource
 * functions which can be passed directly to the like-named properties on the policy class.
 *
 * This is typically used in combination with a spread operator. For example:
 *
 * ```typescript
 * policies: [{
 *     name: "...",
 *     ...validateRemediateResourceOfType(aws.s3.Bucket, (bucket, args, reportViolation) => {
 *         ... change bucket state *and* reportViolations ...
 *     },
 * }]
 * ```
 */
function validateRemediateResourceOfType(resourceClass, validateRemediate) {
    const validateResource = (args, reportViolation) => __awaiter(this, void 0, void 0, function* () {
        if (args.isType(resourceClass)) {
            yield validateRemediate(args.props, args, reportViolation);
        }
        else {
            notApplicableType(args, resourceClass);
        }
    });
    const remediateResource = (args) => {
        if (args.isType(resourceClass)) {
            return validateRemediate(args.props, args, (_, __) => { });
        }
        else {
            notApplicableType(args, resourceClass);
        }
    };
    // If resourceClass has a Pulumi type, attach it to the functions so it can be used for more efficient filtering.
    const pulumiType = getPulumiType(resourceClass);
    if (pulumiType) {
        validateResource.__pulumiType = pulumiType;
        remediateResource.__pulumiType = pulumiType;
    }
    return {
        validateResource,
        remediateResource,
    };
}
exports.validateRemediateResourceOfType = validateRemediateResourceOfType;
/**
 * A helper function that returns a strongly-typed stack validation function, used to check only resources of the
 * specified resource class.
 *
 * For example:
 *
 * ```typescript
 * validateStack: validateStackResourcesOfType(aws.s3.Bucket, (buckets, args, reportViolation) => {
 *     for (const bucket of buckets) {
 *         // ...
 *     }
 * }),
 * ```
 *
 * @param resourceClass Used to filter this check to only resources of the specified resource class.
 * @param validate A callback function that validates if a stack violates a policy.
 */
function validateStackResourcesOfType(resourceClass, validate) {
    const fn = (args, reportViolation) => {
        const filtered = args.resources.filter(r => r.isType(resourceClass));
        if (filtered.length > 0) {
            const filteredTyped = filtered.map(r => r.props);
            const filteredArgs = Object.assign(Object.assign({}, args), { resources: filtered });
            return validate(filteredTyped, filteredArgs, reportViolation);
        }
        else {
            notApplicableType(args, resourceClass);
        }
    };
    // If resourceClass has a Pulumi type, attach it to the function so it can be used for more efficient filtering.
    const pulumiType = getPulumiType(resourceClass);
    if (pulumiType) {
        fn.__pulumiType = pulumiType;
    }
    return fn;
}
exports.validateStackResourcesOfType = validateStackResourcesOfType;
/**
 * Secret allows values to be marked as sensitive, such that the Pulumi engine will encrypt them
 * as normal with Pulumi secrets upon seeing one returned from a remediation.
 */
class Secret {
    /**
     * Constructs a new secret value that will be encrypted.
     * @param value The plaintext value to turn into a secret.
     */
    constructor(value) {
        this.value = value;
    }
}
exports.Secret = Secret;
/**
 * Type guard used to determine if the `Policy` is a `ResourceValidationPolicy`.
 *
 * @internal
 */
function isResourcePolicy(p) {
    // If the policy has a validate routine, it is a resource policy:
    const validation = p.validateResource;
    if (typeof validation === "function") {
        return true;
    }
    if (Array.isArray(validation)) {
        for (const v of validation) {
            if (typeof v !== "function") {
                return false;
            }
        }
        return true;
    }
    // Alternatively, if the policy has a remediation routine, it is also a resource policy.
    const remediation = p.remediateResource;
    if (typeof remediation === "function") {
        return true;
    }
    return false;
}
exports.isResourcePolicy = isResourcePolicy;
/**
 * Type guard used to determine if the `Policy` is a `StackValidationPolicy`.
 *
 * @internal
 */
function isStackPolicy(p) {
    return typeof p.validateStack === "function";
}
exports.isStackPolicy = isStackPolicy;
/**
 * Helper for getting __pulumiType from an object, if it exists and is a non-empty string.
 *
 * @internal
 */
function getPulumiType(obj) {
    const pulumiType = obj === null || obj === void 0 ? void 0 : obj.__pulumiType;
    return (typeof pulumiType === "string" && pulumiType.length > 0) ? pulumiType : undefined;
}
exports.getPulumiType = getPulumiType;
/**
 * Helper to indicate a policy is not applicable for a given resource type.
 */
function notApplicableType(args, resourceClass) {
    var _a;
    const pulumiType = getPulumiType(resourceClass);
    if (pulumiType) {
        return args.notApplicable(`Policy only applies to resources of type '${pulumiType}'`);
    }
    const resourceClassName = (_a = resourceClass) === null || _a === void 0 ? void 0 : _a.name;
    if (typeof resourceClassName === "string" && resourceClassName.length > 0) {
        return args.notApplicable(`Policy only applies to '${resourceClassName}' resources`);
    }
    return args.notApplicable("Policy only applies to resources of a specific type");
}
